# This file was generated. Do not edit manually.

schema {
    query: Query
}

interface Node {
    "Retrieves a record by `ID`"
    nodeId: ID!
}

type ActiveGame implements Node {
    answer: String
    game: Game
    id: UUID!
    "Globally Unique Record Identifier"
    nodeId: ID!
    playersRemaining: Int
    price: String
    question: String
    rightCount: Int!
    round: Int
    roundEnds: BigInt
    startsAt: BigInt!
    winner: UUID
    wrongCount: Int!
}

type ActiveGameConnection {
    edges: [ActiveGameEdge!]!
    pageInfo: PageInfo!
}

type ActiveGameEdge {
    cursor: String!
    node: ActiveGame!
}

type Game implements Node {
    activeGame: ActiveGame
    gameQuestionCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: GameQuestionFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [GameQuestionOrderBy!]
    ): GameQuestionConnection
    id: UUID!
    "Globally Unique Record Identifier"
    nodeId: ID!
    participantCount: Int
    playerGameCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: PlayerGameFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [PlayerGameOrderBy!]
    ): PlayerGameConnection
    price: String!
    startDate: BigInt!
    winner: Player
    winnerId: UUID
}

type GameConnection {
    edges: [GameEdge!]!
    pageInfo: PageInfo!
}

type GameEdge {
    cursor: String!
    node: Game!
}

type GameQuestion implements Node {
    game: Game
    gameId: UUID!
    id: UUID!
    "Globally Unique Record Identifier"
    nodeId: ID!
    questionId: UUID!
    rightCount: Int!
    round: Int!
    startedCount: Int!
    wrongCount: Int!
}

type GameQuestionConnection {
    edges: [GameQuestionEdge!]!
    pageInfo: PageInfo!
}

type GameQuestionEdge {
    cursor: String!
    node: GameQuestion!
}

type PageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type Player implements Node {
    createdAt: Datetime
    gameCount: Int!
    id: UUID!
    "Globally Unique Record Identifier"
    nodeId: ID!
    playerGameCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: PlayerGameFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [PlayerGameOrderBy!]
    ): PlayerGameConnection
    winCount: Int!
    wonGames(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: GameFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [GameOrderBy!]
    ): GameConnection
}

type PlayerConnection {
    edges: [PlayerEdge!]!
    pageInfo: PageInfo!
}

type PlayerEdge {
    cursor: String!
    node: Player!
}

type PlayerGame implements Node {
    answers: JSON!
    eliminated: Boolean!
    game: Game
    gameId: UUID!
    id: UUID!
    "Globally Unique Record Identifier"
    nodeId: ID!
    player: Player
    playerId: UUID!
    price: String
    round: Int!
}

type PlayerGameConnection {
    edges: [PlayerGameEdge!]!
    pageInfo: PageInfo!
}

type PlayerGameEdge {
    cursor: String!
    node: PlayerGame!
}

"The root type for querying data"
type Query {
    "A pagable collection of type `ActiveGame`"
    activeGameCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: ActiveGameFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [ActiveGameOrderBy!]
    ): ActiveGameConnection
    "A pagable collection of type `Game`"
    gameCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: GameFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [GameOrderBy!]
    ): GameConnection
    "A pagable collection of type `GameQuestion`"
    gameQuestionCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: GameQuestionFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [GameQuestionOrderBy!]
    ): GameQuestionConnection
    "Retrieve a record by its `ID`"
    node(
        "The record's `ID`"
        nodeId: ID!
    ): Node
    "A pagable collection of type `Player`"
    playerCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: PlayerFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [PlayerOrderBy!]
    ): PlayerConnection
    "A pagable collection of type `PlayerGame`"
    playerGameCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: PlayerGameFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [PlayerGameOrderBy!]
    ): PlayerGameConnection
}

enum FilterIs {
    NOT_NULL
    NULL
}

"Defines a per-field sorting order"
enum OrderByDirection {
    "Ascending order, nulls first"
    AscNullsFirst
    "Ascending order, nulls last"
    AscNullsLast
    "Descending order, nulls first"
    DescNullsFirst
    "Descending order, nulls last"
    DescNullsLast
}

"A high precision floating point value represented as a string"
scalar BigFloat

"An arbitrary size integer represented as a string"
scalar BigInt

"An opaque string using for tracking a position in results during pagination"
scalar Cursor

"A date wihout time information"
scalar Date

"A date and time"
scalar Datetime

"A Javascript Object Notation value serialized as a string"
scalar JSON

"Any type not handled by the type system"
scalar Opaque

"A time without date information"
scalar Time

"A universally unique identifier"
scalar UUID

input ActiveGameFilter {
    answer: StringFilter
    id: UUIDFilter
    nodeId: IDFilter
    playersRemaining: IntFilter
    price: StringFilter
    question: StringFilter
    rightCount: IntFilter
    round: IntFilter
    roundEnds: BigIntFilter
    startsAt: BigIntFilter
    winner: UUIDFilter
    wrongCount: IntFilter
}

input ActiveGameOrderBy {
    answer: OrderByDirection
    id: OrderByDirection
    playersRemaining: OrderByDirection
    price: OrderByDirection
    question: OrderByDirection
    rightCount: OrderByDirection
    round: OrderByDirection
    roundEnds: OrderByDirection
    startsAt: OrderByDirection
    winner: OrderByDirection
    wrongCount: OrderByDirection
}

"Boolean expression comparing fields on type \"BigFloat\""
input BigFloatFilter {
    eq: BigFloat
    gt: BigFloat
    gte: BigFloat
    in: [BigFloat!]
    is: FilterIs
    lt: BigFloat
    lte: BigFloat
    neq: BigFloat
}

"Boolean expression comparing fields on type \"BigInt\""
input BigIntFilter {
    eq: BigInt
    gt: BigInt
    gte: BigInt
    in: [BigInt!]
    is: FilterIs
    lt: BigInt
    lte: BigInt
    neq: BigInt
}

"Boolean expression comparing fields on type \"Boolean\""
input BooleanFilter {
    eq: Boolean
    is: FilterIs
}

"Boolean expression comparing fields on type \"Date\""
input DateFilter {
    eq: Date
    gt: Date
    gte: Date
    in: [Date!]
    is: FilterIs
    lt: Date
    lte: Date
    neq: Date
}

"Boolean expression comparing fields on type \"Datetime\""
input DatetimeFilter {
    eq: Datetime
    gt: Datetime
    gte: Datetime
    in: [Datetime!]
    is: FilterIs
    lt: Datetime
    lte: Datetime
    neq: Datetime
}

"Boolean expression comparing fields on type \"Float\""
input FloatFilter {
    eq: Float
    gt: Float
    gte: Float
    in: [Float!]
    is: FilterIs
    lt: Float
    lte: Float
    neq: Float
}

input GameFilter {
    id: UUIDFilter
    nodeId: IDFilter
    participantCount: IntFilter
    price: StringFilter
    startDate: BigIntFilter
    winnerId: UUIDFilter
}

input GameOrderBy {
    id: OrderByDirection
    participantCount: OrderByDirection
    price: OrderByDirection
    startDate: OrderByDirection
    winnerId: OrderByDirection
}

input GameQuestionFilter {
    gameId: UUIDFilter
    id: UUIDFilter
    nodeId: IDFilter
    questionId: UUIDFilter
    rightCount: IntFilter
    round: IntFilter
    startedCount: IntFilter
    wrongCount: IntFilter
}

input GameQuestionOrderBy {
    gameId: OrderByDirection
    id: OrderByDirection
    questionId: OrderByDirection
    rightCount: OrderByDirection
    round: OrderByDirection
    startedCount: OrderByDirection
    wrongCount: OrderByDirection
}

"Boolean expression comparing fields on type \"ID\""
input IDFilter {
    eq: ID
}

"Boolean expression comparing fields on type \"Int\""
input IntFilter {
    eq: Int
    gt: Int
    gte: Int
    in: [Int!]
    is: FilterIs
    lt: Int
    lte: Int
    neq: Int
}

"Boolean expression comparing fields on type \"Opaque\""
input OpaqueFilter {
    eq: Opaque
    is: FilterIs
}

input PlayerFilter {
    createdAt: DatetimeFilter
    gameCount: IntFilter
    id: UUIDFilter
    nodeId: IDFilter
    winCount: IntFilter
}

input PlayerGameFilter {
    eliminated: BooleanFilter
    gameId: UUIDFilter
    id: UUIDFilter
    nodeId: IDFilter
    playerId: UUIDFilter
    price: StringFilter
    round: IntFilter
}

input PlayerGameOrderBy {
    eliminated: OrderByDirection
    gameId: OrderByDirection
    id: OrderByDirection
    playerId: OrderByDirection
    price: OrderByDirection
    round: OrderByDirection
}

input PlayerOrderBy {
    createdAt: OrderByDirection
    gameCount: OrderByDirection
    id: OrderByDirection
    winCount: OrderByDirection
}

"Boolean expression comparing fields on type \"String\""
input StringFilter {
    eq: String
    gt: String
    gte: String
    ilike: String
    in: [String!]
    is: FilterIs
    like: String
    lt: String
    lte: String
    neq: String
    startsWith: String
}

"Boolean expression comparing fields on type \"Time\""
input TimeFilter {
    eq: Time
    gt: Time
    gte: Time
    in: [Time!]
    is: FilterIs
    lt: Time
    lte: Time
    neq: Time
}

"Boolean expression comparing fields on type \"UUID\""
input UUIDFilter {
    eq: UUID
    in: [UUID!]
    is: FilterIs
    neq: UUID
}
