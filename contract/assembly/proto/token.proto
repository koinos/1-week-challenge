syntax = "proto3";

package token;

import "koinos/options.proto"; 

message empty_message {}

// @description Returns the token's name
// @read-only true
message name_arguments {}

message name_result {
   string value = 1;
}

// @description Returns the token's symbol
// @read-only true
message symbol_arguments {}

message symbol_result {
   string value = 1;
}

// @description Returns the token's decimals precision
// @read-only true
message decimals_arguments {}

message decimals_result {
   uint32 value = 1;
}

// @description Returns the token's total supply
// @read-only true
message total_supply_arguments {}

message total_supply_result {
   uint64 value = 1 [jstype = JS_STRING];
}

// @description Returns the token's max supply
// @read-only true
message max_supply_arguments {}

message max_supply_result {
   uint64 value = 1 [jstype = JS_STRING];
}

// @description Checks the balance at an address
// @read-only true
message balance_of_arguments {
   bytes owner = 1 [(koinos.btype) = ADDRESS];
}

message balance_of_result {
   uint64 value = 1 [jstype = JS_STRING];
}

// @description Transfers the token
// @read-only false
// @result empty_message
message transfer_arguments {
   bytes from = 1 [(koinos.btype) = ADDRESS];
   bytes to = 2 [(koinos.btype) = ADDRESS];
   uint64 value = 3 [jstype = JS_STRING];
}

// @description Mints the token
// @read-only false
// @result empty_message
message mint_arguments {
   bytes to = 1 [(koinos.btype) = ADDRESS];
   uint64 value = 2 [jstype = JS_STRING];
   // workshop: add this new field to mint_arguments
   game_stats_object game_stats = 3;
}

// @description Burns the token
// @read-only false
// @result empty_message
message burn_arguments {
   bytes from = 1 [(koinos.btype) = ADDRESS];
   uint64 value = 2 [jstype = JS_STRING];
}

// workshop: add this new entry point
// @description Return a player's info
// @read-only true
// @result player_object
message get_player_info_arguments {
   bytes player = 1 [(koinos.btype) = ADDRESS];
}

// workshop: add this new entry point
// @description Return the leaderboard
// @read-only true
message get_leaderboard_arguments {
   leaderboard_key offset_key = 1;
   uint64 limit = 2 [jstype = JS_STRING];
   bool descending = 3;
}

message get_leaderboard_result {
   repeated leaderboard_key leaderboard = 1;
}

// workshop: add this new entry point
// @description Return the past games stats
// @read-only true
message get_games_stats_arguments {
   game_stats_key offset_key = 1;
   uint64 limit = 2 [jstype = JS_STRING];
   bool descending = 3;
}

message get_games_stats_result {
   repeated game_stats_object games_stats = 1;
}

// objects
message balance_object {
   uint64 value = 1 [jstype = JS_STRING];
}

// workshop: add this new proto message
message game_stats_key {
   uint64 timestamp = 1;
}

// workshop: add this new proto message
message game_stats_object {
   bytes winner = 1 [(koinos.btype) = ADDRESS];
   // other fields?
}

// workshop: add this new proto message
message leaderboard_key {
   uint32 wins = 1;
   bytes player = 2;
}

// workshop: add this new proto message
message player_object {
   uint32 wins = 1;
   // other fields?
}

// events
message mint_event {
   bytes to = 1 [(koinos.btype) = ADDRESS];
   uint64 value = 2 [jstype = JS_STRING];
}

message burn_event {
   bytes from = 1 [(koinos.btype) = ADDRESS];
   uint64 value = 2 [jstype = JS_STRING];
}

message transfer_event {
   bytes from = 1 [(koinos.btype) = ADDRESS];
   bytes to = 2 [(koinos.btype) = ADDRESS];
   uint64 value = 3 [jstype = JS_STRING];
}
